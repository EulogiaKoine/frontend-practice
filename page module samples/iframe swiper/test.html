<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="swiper"
        style="width: 90%; height: 600px; background-color: rgba(199, 199, 199, 0.3); margin: auto;">
        <div style="width: 300px; height: 200px; text-align: center; background-color: rgba(226, 1, 1, 0.1);"
            data-is-page>
            TEST
        </div>
        <div style="width: 300px; height: 200px; text-align: center; background-color: rgba(1, 225, 1, 0.1);"
            data-is-page>
            YEEEEEEEE
        </div>
    </div>
    <script>
        function clamp(x, a, b){
            if(x < a) return a
            if(b < x) return b
            return x
        }

        class Swipeable {
            cont = null // container
            containerWidth = 0
            highlighted = 0 // 하이라이트된 페이지
            originX = 0 // 컨테이너 중심 x좌표(width/2, px)
            // offsetX = 0 // 오른쪽(+)으로 밀린 정도(px)
            startX = 0 // 클릭 시작 X
            pages = []
            $gap = [200] // px
            get gap(){ return this.$gap.slice() }
            set gap(v){
                if(Array.isArray(v)){
                    this.$gap = v.filter(gap => typeof gap === 'number')
                    if(this.$gap.length === 0){
                        this.$gap = [100]
                        throw new TypeError("gap(s) must be number[>0]")
                    }
                } else if(typeof v === 'number' && v > 0)
                    this.$gap = [v]
                else
                    throw new TypeError("gap(s) must be number[>0]")
            }
            // 요소 크기 변경 시 동적으로 조정
            resizer = null
            animation = true; setAnimation(go){ this.animation = !!go } // 애니메이션 여부
            targetDX = 0 // [animation] 스와이프 목표 변화값 (전체 스와이프될 거리)
            aniReq = null // 애니메이션 request id
            animationStartTime = 0; // [animation] 애니메이션 시작 시간
            animationDuration = 300 // ms

            constructor(element){
                if(element instanceof HTMLElement)
                    this.init(element)
                else
                    console.error("요소 입력 필수")
            }
            init(cont){
                this.cont = cont
                cont.style.position = 'relative'
                this.originX = (
                    this.containerWidth = parseFloat(window.getComputedStyle(cont).width)
                ) / 2

                Array.from(cont.children).filter(e => e.hasAttribute('data-is-page'))
                    .forEach(e => {
                        this.initPage(e)
                        this.pages.push(e)
                    })

                this.initPagePositions()
                this.initSizeObserver()

                // 마우스 조작
                this.cont.addEventListener('mousedown', this.handleMouseDown)
            }
            initSizeObserver(){
                if(this.resizer !== null)
                    this.resizer.disconnect()

                this.resizer = new ResizeObserver(entry => { // 컨테이너만 관측
                    entry = entry[0]
                    this.containerWidth = entry.contentRect.width
                    this.originX = this.containerWidth / 2

                    this.initPagePositions()
                    this.highlighted = this.calculateHighlighted()
                })

                this.resizer.observe(this.cont)
            }
            initPage(e){ // element
                if(!e.style.display.includes('block'))
                    e.style.display = 'block'
                // 좌표 기반 배치가 가능하도록 + 높이는 기본적으로 중간
                e.style.position = 'absolute'
                e.style.top = '50%'
                e.style.transform = "translate(-50%, -50%) translateX(0px)"

                // 중심으로부터의 거리에 따른 불투명도와 스케일
                // e.style.setAttribute('--distance', '0%')
                // e.style.opacity = "calc((100% - abs(var(--distance))) / 100%)"
                // e.style.transform += " scale(calc(100% - abs(var(--distance))))"
            }
            initPagePositions(){
                this.pages.forEach((page, i) => this.setPageX(i, this.calculateX(i)))
            }
            getPagePosition(i){
                if(i < 0 || this.pages.length < i)
                    throw new Error("페이지 인덱스 이탈")
                const match = this.pages[i].style.transform.match(/translateX\(([-]?[\d.]+)px\)/)
                return match? parseFloat(match[1]): 0
            }
            calculateDistanceFromOrigin(i){
                if(i < 0 || this.pages.length < i)
                    throw new Error("페이지 인덱스 이탈")
                return Math.abs(this.originX - this.getPagePosition(i))
            }
            setPageX(i, x){
                if(i < 0 || this.pages.length < i)
                    throw new Error("페이지 인덱스 이탈")
                const page = this.pages[i]
                // page.style.left = x+'px'
                if(page.style.transform.includes('translateX'))
                    page.style.transform = page.style.transform.replace(/translateX\(.+\)/, `translateX(${x}px)`)
                else
                    page.style.transform += ` translateX(${x}px)`
                this.styleByDistanceFromOrigin(page, this.calculateDistanceFromOrigin(i))
            }
            styleByDistanceFromOrigin(page, distance){
                // assert page is Page
                // 불투명도+스케일 조정 적용; 끝에서 완전히 사라지도록
                const near = (this.originX*1.5 - distance)/this.originX/1.5
                page.style.opacity = near.toString()
                if(page.style.transform.includes('scale'))
                    page.style.transform = page.style.transform.replace(/scale\(.+\)/, `scale(${near*100}%)`)
                else
                    page.style.transform += ` scale(${Math.cbrt(near) *100}%)`
            }


            // 하이라이트(중심) 기준 각 페이지별 핀 좌표(x) 계산
            calculateX(page){
                const d_page = page - this.highlighted
                return this.originX
                    + this.$gap.slice(0, Math.min(Math.abs(d_page), this.$gap.length))
                        .reduce((a, v) => a+v, 0) * (d_page > 0? 1: -1)
            }
            calculateHighlighted(){
                let res = 0
                let distance = this.calculateDistanceFromOrigin(0)
                for(let i = 1, dx; i < this.pages.length; i++){
                    dx = this.calculateDistanceFromOrigin(i)
                    if(dx < distance){
                        res = i
                        distance = dx
                    }
                }
                return res
            }

            // 시작-끝-시작이 부드럽게 이어지도록 ease-in-out식
            easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }

            // 모든 일괄 이동 시 애니메이션 처리 관장(개별 페이지 애니메이션 처리는 부하 때문에 패스)
            swipe(dx){
                // 애니메이션 모드
                if(this.animation){
                    // 이미 진행 중인 애니메이션이 있다면 취소
                    if(this.aniReq)
                        cancelAnimationFrame(this.aniReq)

                    this.targetDX = dx // 목표로 할 총 이동 거리 저장
                    this.animationStartTime = performance.now() // 애니메이션 시작 시간 기록

                    // 각 페이지의 현재 위치를 애니메이션 시작점으로 저장
                    // 애니메이션 시작 시점에 이미 translateX가 적용되어 있으므로 그 값을 가져옴
                    this.initialPagePositions = this.pages
                        .map(page => this.getPagePosition(this.pages.indexOf(page)))

                    this.aniReq = requestAnimationFrame(this.traceAnimation); // 애니메이션 시작
                } else {
                    // 비 애니메이션 모드
                    this.pages.forEach((page, i) => {
                        this.setPageX(i, this.getPagePosition(i) + dx)
                    })
                }
            }

            setHighlighted(idx){
                if(idx < 0 || this.pages.length <= idx) // 인덱스 범위 오류 수정: <=
                    throw new RangeError(`없는 페이지 ${idx}`);

                // 목표 하이라이트 페이지를 중앙(originX)으로 이동시키기 위한 dx 계산
                const currentHighlightedPageX = this.getPagePosition(idx); // 현재 이 페이지의 translateX 값
                const dxToCenter = this.originX - currentHighlightedPageX; // 중심까지 이동해야 할 거리

                this.swipe(dxToCenter); // 계산된 dx를 swipe 메서드에 전달
                this.highlighted = idx;
            }
            swipePage(di){
                if(di === 0) return
                // todo: repeatable
                this.setHighlighted(clamp(this.highlighted + di, 0, this.pages.length-1))
            }
            snap(){
                this.setHighlighted(this.calculateHighlighted())
            }


            // 마우스 조작
            handleMouseDown = e => { // 컨테이너 위 클릭
                // 마우스 드래그 시작 시 애니메이션 중단
                if (this.aniReq) {
                    cancelAnimationFrame(this.aniReq);
                    this.aniReq = null
                }
                this.startX = e.clientX
                document.body.addEventListener('mousemove', this.handleMouseMove)
                document.body.addEventListener('mouseup', this.handleMouseUp)
            }
            handleMouseMove = e => {
                // 드래그 중에는 애니메이션을 끄고 직접 위치 업데이트
                // this.animation 플래그를 여기서 false로 설정하거나,
                // handleMouseMove가 animation=false일 때만 호출되도록 로직 조정 필요
                // 현재 코드에서는 이 조건이 필요 없음: 이미 swipe에서 animation 플래그를 처리함
                // 하지만 드래그 중에는 애니메이션이 아닌 즉각적인 이동이므로, animation=false인 것처럼 동작
                this.pages.forEach((page, i) => {
                    this.setPageX(i, this.getPagePosition(i) + (e.clientX - this.startX))
                })
                this.startX = e.clientX
            }
            handleMouseUp = e => {
                document.body.removeEventListener('mousemove', this.handleMouseMove)
                document.body.removeEventListener('mouseup', this.handleMouseUp)
                // 마우스 드래그가 끝나면 스냅 애니메이션 시작 (animation 플래그에 따라 동작)
                this.snap()
            }

            // 애니메이션
            traceAnimation = timeStamp => {
                const elapsed = timeStamp - this.animationStartTime
                let progress = elapsed / this.animationDuration

                // 애니메이션이 끝나면 최종 위치로 설정하고 종료
                if (progress >= 1) {
                    this.pages.forEach((page, i) => {
                        this.setPageX(i, this.initialPagePositions[i] + this.targetDX);
                    })
                    cancelAnimationFrame(this.aniReq)
                    this.aniReq = null
                    this.targetDX = 0 // 목표 변화량 초기화
                    return
                }

                const easedProgress = this.easeInOutQuad(progress)

                // 현재 프레임에서 각 페이지의 위치 계산 및 업데이트
                this.pages.forEach((page, i) => {
                    const currentDX = this.targetDX * easedProgress;
                    this.setPageX(i, this.initialPagePositions[i] + currentDX);
                })

                this.aniReq = requestAnimationFrame(this.traceAnimation)
            }
        }


        var swiper = new Swipeable(document.getElementById('swiper'))
        // 테스트를 위해 애니메이션 활성화
    </script>
</body>
</html>